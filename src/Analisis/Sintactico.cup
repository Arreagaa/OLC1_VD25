package Analisis;
// importaciones
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import Abstracto.Instruccion;
import Simbolo.Tipo;
import Simbolo.tipoDato;
import Excepciones.Errores;
import Instrucciones.Print;
import Expresiones.Nativo;
import Expresiones.Aritmeticas;
import Expresiones.OperadoresAritmeticos;
import Expresiones.Relacionales;
import Expresiones.OperadoresRelacionales;
import Expresiones.Logicas;
import Expresiones.OperadoresLogicos;
import Instrucciones.Declaracion;
import Instrucciones.AsignacionVar;
import Instrucciones.If;
import Expresiones.AccesoVar;
import Instrucciones.While;
import Instrucciones.For;
import Instrucciones.DoWhile;
import Instrucciones.Break;
import Instrucciones.Continue;
import Instrucciones.Switch;
import Instrucciones.Case;
import Instrucciones.Default;
import Instrucciones.IncrementoDecremento;
import Expresiones.Casteo;
// Nuevas importaciones para vectores
import Instrucciones.DeclaracionVector;
import Expresiones.AccesoVector;
import Instrucciones.AsignacionVector;
// Nuevas importaciones para listas
import Instrucciones.DeclaracionLista;
import Expresiones.AccesoLista;
import Instrucciones.AsignacionLista;
import Instrucciones.ListaAppend;
import Expresiones.ListaRemove;
// Funciones nativas
import Expresiones.Round;
import Expresiones.Length;
import Expresiones.ToString;
import Expresiones.Find;
// Funciones, métodos, return, start
import Instrucciones.Return;
import Instrucciones.DeclaracionFuncion;
import Instrucciones.DeclaracionMetodo;
import Expresiones.Llamada;
import Instrucciones.Start;
import java.util.HashMap;

parser code
{:
    public LinkedList<Errores> listaErrores = new LinkedList<>();
    
    public void syntax_error(Symbol s){
        if (s == null) {
            listaErrores.add(new Errores("SINTACTICO", "Token nulo (posible error lexico)", -1, -1));
            System.out.println("Error sintactico: token nulo (posible error lexico)");
            return;
        }
        
        listaErrores.add(new Errores("SINTACTICO", "No se esperaba el componente: " + s.value, s.left, s.right));
        System.out.println(
            "Error sintactico en linea " + s.left +
            " columna " + s.right +
            " token: " + s.value
        );
    }

    public void unrecovered_syntax_error(Symbol s){
        listaErrores.add(new Errores("SINTACTICO", "Error fatal: " + s.value, s.left, s.right));
        System.out.println("Error sintactico fatal en linea " + s.left +
                           " columna " + s.right);
    }
:}


action code
{:
:}

//terminales
terminal String CADENA, ENTERO, DECIMAL, ID;
terminal Character CHAR;
terminal FINCADENA, PRINT, PAR1, PAR2, LLAVE1, LLAVE2, DOSPUNTOS;
terminal CORCHETE1, CORCHETE2, COMA, PUNTO;
terminal MAS, MENOS, MULTI, DIV, MOD, POT, UMENOS;
terminal IGUAL, EQUALS, DIFERENTE, MENORQ, MENORIGUAL, MAYORQ, MAYORIGUAL;
terminal OR, AND, XOR, NOT;
terminal TRUE, FALSE;
terminal VAR, INT, DOUBLE, BOOL, CHAR_TYPE, STRING;
terminal _if, _else;
terminal _while, _for, _do;
terminal _break, _continue;
terminal _switch, _case, _default;
terminal INCREMENTO, DECREMENTO;
terminal _list, _new, _append, _remove;
terminal ROUND, LENGTH, TOSTRING, FIND, RETURN, VOID, START;

// no terminales
nonterminal LinkedList<Instruccion> INICIO, INSTRUCCIONES;
nonterminal Instruccion INSTRUCCION;
nonterminal Instruccion EXPRESION;
nonterminal Instruccion DECLARACION, ASIGNACION;
nonterminal Tipo TIPOS;
nonterminal Instruccion SIF;
nonterminal LinkedList<Instruccion> ELSEIF;
nonterminal Instruccion WHILE, FOR, DOWHILE;
nonterminal Instruccion BREAK, CONTINUE, INCR_DECR;
nonterminal Instruccion SWITCH;
nonterminal LinkedList<Case> CASES_LIST;
nonterminal Case CASE;
nonterminal Default DEFAULT;
nonterminal Instruccion FOR_INIT;
nonterminal Instruccion LISTA_METODO;
nonterminal LinkedList<Instruccion> LISTA_VALORES, FILA_VALORES;
nonterminal LinkedList<LinkedList<Instruccion>> LISTA_VALORES_2D;
nonterminal Instruccion FUNCION, METODO, RETURN_STMT, START_STMT, LLAMADA_INST;
nonterminal LinkedList<HashMap<String, Object>> PARAMETROS, PARAMETROS_DECL;
nonterminal LinkedList<Instruccion> PARAMETROS_LLAMADA;

// precedencia segun enunciado
precedence left OR;
precedence left AND;
precedence left XOR;
precedence right NOT;
precedence left EQUALS, DIFERENTE, MENORQ, MENORIGUAL, MAYORQ, MAYORIGUAL;
precedence left MAS, MENOS;
precedence left MULTI, DIV, MOD;
precedence nonassoc POT;
precedence right UMENOS;

start with INICIO;

INICIO ::= INSTRUCCIONES:a   {: RESULT = a; :}
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b {: RESULT = a; RESULT.add(b); :}
                | INSTRUCCION:a                {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

INSTRUCCION ::= PRINT PAR1 EXPRESION:a PAR2 FINCADENA
                {: RESULT = new Print(a, aleft, aright); :}
              | DECLARACION:a   {: RESULT = a; :}
              | ASIGNACION:a    {: RESULT = a; :}
              | SIF:a            {:RESULT = a; :}
              | WHILE:a          {:RESULT = a; :}
              | FOR:a            {:RESULT = a; :}
              | DOWHILE:a        {:RESULT = a; :}
              | SWITCH:a         {:RESULT = a; :}
              | BREAK:a          {:RESULT = a; :}
              | CONTINUE:a       {:RESULT = a; :}
              | INCR_DECR:a      {:RESULT = a; :}
              | LISTA_METODO:a   {:RESULT = a; :}
              | FUNCION:a        {:RESULT = a; :}
              | METODO:a         {:RESULT = a; :}
              | RETURN_STMT:a    {:RESULT = a; :}
              | START_STMT:a     {:RESULT = a; :}
              | LLAMADA_INST:a   {:RESULT = a; :}
              | error FINCADENA
              | error
;

SIF ::= _if PAR1 EXPRESION:a PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2 {: RESULT = new If(a, b, aleft, aright); :}
        | _if PAR1 EXPRESION:a PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2 _else LLAVE1 INSTRUCCIONES:c LLAVE2 {: RESULT =  new If(a, b, c, aleft, aright); :}
        | _if PAR1 EXPRESION:a PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2 ELSEIF:c {: RESULT =  new If(a, b, c, null, aleft, aright); :}
        | _if PAR1 EXPRESION:a PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2 ELSEIF:c _else LLAVE1 INSTRUCCIONES:d LLAVE2  {: RESULT =  new If(a, b, c, d, aleft, aright); :}
;

ELSEIF ::=  ELSEIF:m _else _if PAR1 EXPRESION:a PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2 {:RESULT=m; RESULT.add(new If(a, b, aleft, aright));:}
            | _else _if PAR1 EXPRESION:a PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2 {: RESULT =  new LinkedList<>(); RESULT.add(new If(a, b, aleft, aright));:}
;

// ========== DECLARACIONES ==========

DECLARACION ::= VAR ID:b DOSPUNTOS TIPOS:a IGUAL EXPRESION:c FINCADENA 
                {: RESULT = new Declaracion(b, c, a, bleft, bright); :}
              | VAR ID:b DOSPUNTOS TIPOS:a FINCADENA
                {: RESULT = new Declaracion(b, null, a, bleft, bright); :}
              // Vectores 1D
              | VAR ID:b DOSPUNTOS TIPOS:a CORCHETE1 CORCHETE2 IGUAL CORCHETE1 LISTA_VALORES:c CORCHETE2 FINCADENA
                {: RESULT = new DeclaracionVector(b, a, c, bleft, bright); :}
              // Vectores 2D
              | VAR ID:b DOSPUNTOS TIPOS:a CORCHETE1 CORCHETE2 CORCHETE1 CORCHETE2 IGUAL CORCHETE1 LISTA_VALORES_2D:c CORCHETE2 FINCADENA
                {: RESULT = new DeclaracionVector(b, a, c, bleft, bright, true); :}
              // Listas dinámicas: var lst: list<int> = new list();
              | VAR ID:b DOSPUNTOS _list MENORQ TIPOS:a MAYORQ IGUAL _new _list PAR1 PAR2 FINCADENA
                {: RESULT = new DeclaracionLista(b, a, bleft, bright); :}
              // Listas dinámicas sin var: List<int> lista = new List();
              | _list MENORQ TIPOS:a MAYORQ ID:b IGUAL _new _list PAR1 PAR2 FINCADENA
                {: RESULT = new DeclaracionLista(b, a, bleft, bright); :}
;

// ========== ASIGNACIONES ==========

ASIGNACION ::= ID:a IGUAL EXPRESION:b FINCADENA 
               {: RESULT = new AsignacionVar(a, b, aleft, aright); :}
             // Asignación a vector 1D
             | ID:a CORCHETE1 EXPRESION:b CORCHETE2 IGUAL EXPRESION:c FINCADENA
               {: RESULT = new AsignacionVector(a, b, c, aleft, aright); :}
             // Asignación a vector 2D
             | ID:a CORCHETE1 EXPRESION:b CORCHETE2 CORCHETE1 EXPRESION:c CORCHETE2 IGUAL EXPRESION:d FINCADENA
               {: RESULT = new AsignacionVector(a, b, c, d, aleft, aright); :}
;

// ========== LISTAS DE VALORES PARA VECTORES ==========

LISTA_VALORES ::= LISTA_VALORES:a COMA EXPRESION:b
                  {: RESULT = a; RESULT.add(b); :}
                | EXPRESION:a
                  {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

FILA_VALORES ::= CORCHETE1 LISTA_VALORES:a CORCHETE2
                 {: RESULT = a; :}
;

LISTA_VALORES_2D ::= LISTA_VALORES_2D:a COMA FILA_VALORES:b
                     {: RESULT = a; RESULT.add(b); :}
                   | FILA_VALORES:a
                     {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

// ========== MÉTODOS DE LISTAS ==========

LISTA_METODO ::= ID:a PUNTO _append PAR1 EXPRESION:b PAR2 FINCADENA
                 {: RESULT = new ListaAppend(a, b, aleft, aright); :}
;

TIPOS ::= INT         {: RESULT = new Tipo(tipoDato.ENTERO); :}
        | DOUBLE      {: RESULT = new Tipo(tipoDato.DECIMAL); :}
        | BOOL        {: RESULT = new Tipo(tipoDato.BOOLEANO); :}
        | CHAR_TYPE   {: RESULT = new Tipo(tipoDato.CARACTER); :}
        | STRING      {: RESULT = new Tipo(tipoDato.CADENA); :}
;

// ========== SENTENCIAS CICLICAS ==========

WHILE ::= _while PAR1 EXPRESION:a PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2 
          {: RESULT = new While(a, b, aleft, aright); :}
;

FOR ::= _for PAR1 FOR_INIT:a EXPRESION:b FINCADENA ID:c IGUAL EXPRESION:d PAR2 LLAVE1 INSTRUCCIONES:e LLAVE2
        {: RESULT = new For(a, b, new AsignacionVar(c, d, cleft, cright), e, aleft, aright); :}
      | _for PAR1 FOR_INIT:a EXPRESION:b FINCADENA ID:c INCREMENTO PAR2 LLAVE1 INSTRUCCIONES:d LLAVE2
        {: RESULT = new For(a, b, new IncrementoDecremento(c, true, cleft, cright), d, aleft, aright); :}
      | _for PAR1 FOR_INIT:a EXPRESION:b FINCADENA ID:c DECREMENTO PAR2 LLAVE1 INSTRUCCIONES:d LLAVE2
        {: RESULT = new For(a, b, new IncrementoDecremento(c, false, cleft, cright), d, aleft, aright); :}
;

FOR_INIT ::= DECLARACION:a {: RESULT = a; :}
           | ASIGNACION:a  {: RESULT = a; :}
;

DOWHILE ::= _do LLAVE1 INSTRUCCIONES:a LLAVE2 _while PAR1 EXPRESION:b PAR2 FINCADENA
            {: RESULT = new DoWhile(a, b, aleft, aright); :}
;

// ========== SENTENCIAS DE TRANSFERENCIA ==========

BREAK ::= _break:a FINCADENA 
          {: RESULT = new Break(aleft, aright); :}
;

CONTINUE ::= _continue:a FINCADENA 
             {: RESULT = new Continue(aleft, aright); :}
;

INCR_DECR ::= ID:a INCREMENTO FINCADENA 
              {: RESULT = new IncrementoDecremento(a, true, aleft, aright); :}
            | ID:a DECREMENTO FINCADENA
              {: RESULT = new IncrementoDecremento(a, false, aleft, aright); :}
;

// ========== SWITCH/CASE/DEFAULT ==========

SWITCH ::= _switch PAR1 EXPRESION:a PAR2 LLAVE1 CASES_LIST:b DEFAULT:c LLAVE2
           {: RESULT = new Switch(a, b, c, aleft, aright); :}
         | _switch PAR1 EXPRESION:a PAR2 LLAVE1 CASES_LIST:b LLAVE2
           {: RESULT = new Switch(a, b, aleft, aright); :}
         | _switch PAR1 EXPRESION:a PAR2 LLAVE1 DEFAULT:c LLAVE2
           {: RESULT = new Switch(a, new LinkedList<>(), c, aleft, aright); :}
;

CASES_LIST ::= CASES_LIST:a CASE:b 
               {: RESULT = a; RESULT.add(b); :}
             | CASE:a 
               {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

CASE ::= _case EXPRESION:a DOSPUNTOS INSTRUCCIONES:b
         {: RESULT = new Case(a, b, aleft, aright); :}
       | _case EXPRESION:a DOSPUNTOS
         {: RESULT = new Case(a, new LinkedList<>(), aleft, aright); :}
;

DEFAULT ::= _default:d DOSPUNTOS INSTRUCCIONES:a
            {: RESULT = new Default(a, dleft, dright); :}
          | _default:d DOSPUNTOS
            {: RESULT = new Default(new LinkedList<>(), dleft, dright); :}
;

// ========== EXPRESIONES ==========

EXPRESION ::= MENOS EXPRESION:a           {: RESULT = new Aritmeticas(OperadoresAritmeticos.NEGACION, a, aleft, aright); :} %prec UMENOS
              | NOT EXPRESION:a           {: RESULT = new Logicas(OperadoresLogicos.NOT, a, aleft, aright); :}
              | PAR1 INT PAR2 EXPRESION:a {: RESULT = new Casteo(new Tipo(tipoDato.ENTERO), a, aleft, aright); :} %prec UMENOS
              | PAR1 DOUBLE PAR2 EXPRESION:a {: RESULT = new Casteo(new Tipo(tipoDato.DECIMAL), a, aleft, aright); :} %prec UMENOS
              | PAR1 CHAR_TYPE PAR2 EXPRESION:a {: RESULT = new Casteo(new Tipo(tipoDato.CARACTER), a, aleft, aright); :} %prec UMENOS
              | PAR1 STRING PAR2 EXPRESION:a {: RESULT = new Casteo(new Tipo(tipoDato.CADENA), a, aleft, aright); :} %prec UMENOS
              | EXPRESION:a OR EXPRESION:b {: RESULT = new Logicas(a, b, OperadoresLogicos.OR, aleft, aright); :}
              | EXPRESION:a AND EXPRESION:b {: RESULT = new Logicas(a, b, OperadoresLogicos.AND, aleft, aright); :}
              | EXPRESION:a XOR EXPRESION:b {: RESULT = new Logicas(a, b, OperadoresLogicos.XOR, aleft, aright); :}
              | EXPRESION:a EQUALS EXPRESION:b {: RESULT = new Relacionales(a, b, OperadoresRelacionales.EQUALS, aleft, aright); :}
              | EXPRESION:a DIFERENTE EXPRESION:b {: RESULT = new Relacionales(a, b, OperadoresRelacionales.NOTEQUALS, aleft, aright); :}
              | EXPRESION:a MENORQ EXPRESION:b {: RESULT = new Relacionales(a, b, OperadoresRelacionales.MENOR, aleft, aright); :}
              | EXPRESION:a MENORIGUAL EXPRESION:b {: RESULT = new Relacionales(a, b, OperadoresRelacionales.MENORIGUAL, aleft, aright); :}
              | EXPRESION:a MAYORQ EXPRESION:b {: RESULT = new Relacionales(a, b, OperadoresRelacionales.MAYOR, aleft, aright); :}
              | EXPRESION:a MAYORIGUAL EXPRESION:b {: RESULT = new Relacionales(a, b, OperadoresRelacionales.MAYORIGUAL, aleft, aright); :}
              | EXPRESION:a MAS EXPRESION:b  {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.SUMA, aleft, aright); :}
              | EXPRESION:a MENOS EXPRESION:b {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.RESTA, aleft, aright); :}
              | EXPRESION:a MULTI EXPRESION:b {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MULTIPLICACION, aleft, aright); :}
              | EXPRESION:a DIV EXPRESION:b {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.DIVISION, aleft, aright); :}
              | EXPRESION:a POT EXPRESION:b {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.POTENCIA, aleft, aright); :}
              | EXPRESION:a MOD EXPRESION:b {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MODULO, aleft, aright); :}
              | PAR1 EXPRESION:a PAR2  {: RESULT = a; :}
              | ENTERO:a       {: RESULT = new Nativo(Integer.parseInt(a), new Tipo(tipoDato.ENTERO), aleft, aright);:}   
              | DECIMAL:a   {: RESULT = new Nativo(new Double(a), new Tipo(tipoDato.DECIMAL), aleft, aright);:}
              | CHAR:a {: RESULT = new Nativo(a, new Tipo(tipoDato.CARACTER), aleft, aright); :}
              | CADENA:a    {: RESULT = new Nativo(a, new Tipo(tipoDato.CADENA), aleft, aright);:}
              | ID:a        {: RESULT = new AccesoVar(a, aleft, aright); :}
              | TRUE:a      {: RESULT = new Nativo(true, new Tipo(tipoDato.BOOLEANO), aleft, aright ); :}
              | FALSE:a     {: RESULT = new Nativo(false, new Tipo(tipoDato.BOOLEANO), aleft, aright ); :}
              // Acceso a vectores 1D
              | ID:a CORCHETE1 EXPRESION:b CORCHETE2
                {: RESULT = new AccesoVector(a, b, aleft, aright); :}
              // Acceso a vectores 2D
              | ID:a CORCHETE1 EXPRESION:b CORCHETE2 CORCHETE1 EXPRESION:c CORCHETE2
                {: RESULT = new AccesoVector(a, b, c, aleft, aright); :}
              // Método remove de listas
              | ID:a PUNTO _remove PAR1 EXPRESION:b PAR2
                {: RESULT = new ListaRemove(a, b, aleft, aright); :}
              // Llamada a función como expresión
              | ID:a PAR1 PARAMETROS_LLAMADA:b PAR2
                {: RESULT = new Llamada(a, b, aleft, aright); :}
              | ID:a PAR1 PAR2
                {: RESULT = new Llamada(a, new LinkedList<>(), aleft, aright); :}
              // ===== FUNCIONES NATIVAS =====
              | ROUND PAR1 EXPRESION:a PAR2
                {: RESULT = new Round(a, aleft, aright); :}
              | LENGTH PAR1 EXPRESION:a PAR2
                {: RESULT = new Length(a, aleft, aright); :}
              | TOSTRING PAR1 EXPRESION:a PAR2
                {: RESULT = new ToString(a, aleft, aright); :}
              | ID:a PUNTO FIND PAR1 EXPRESION:b PAR2
                {: RESULT = new Find(a, b, aleft, aright); :}
;

// ========== FUNCIONES Y MÉTODOS ==========

FUNCION ::= TIPOS:a ID:b PAR1 PARAMETROS_DECL:c PAR2 LLAVE1 INSTRUCCIONES:d LLAVE2
            {: RESULT = new DeclaracionFuncion(a, b, c, d, bleft, bright); :}
          | TIPOS:a ID:b PAR1 PAR2 LLAVE1 INSTRUCCIONES:c LLAVE2
            {: RESULT = new DeclaracionFuncion(a, b, new LinkedList<>(), c, bleft, bright); :}
;

METODO ::= VOID ID:a PAR1 PARAMETROS_DECL:b PAR2 LLAVE1 INSTRUCCIONES:c LLAVE2
           {: RESULT = new DeclaracionMetodo(a, b, c, aleft, aright); :}
         | VOID ID:a PAR1 PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2
           {: RESULT = new DeclaracionMetodo(a, new LinkedList<>(), b, aleft, aright); :}
;

PARAMETROS_DECL ::= PARAMETROS_DECL:a COMA TIPOS:b ID:c
                    {:
                        RESULT = a;
                        HashMap<String, Object> param = new HashMap<>();
                        param.put("tipo", b);
                        param.put("id", c);
                        param.put("isArray", false);
                        RESULT.add(param);
                    :}
                  | PARAMETROS_DECL:a COMA TIPOS:b ID:c CORCHETE1 CORCHETE2
                    {:
                        RESULT = a;
                        HashMap<String, Object> param = new HashMap<>();
                        param.put("tipo", b);
                        param.put("id", c);
                        param.put("isArray", true);
                        RESULT.add(param);
                    :}
                  | TIPOS:a ID:b
                    {:
                        RESULT = new LinkedList<>();
                        HashMap<String, Object> param = new HashMap<>();
                        param.put("tipo", a);
                        param.put("id", b);
                        param.put("isArray", false);
                        RESULT.add(param);
                    :}
                  | TIPOS:a ID:b CORCHETE1 CORCHETE2
                    {:
                        RESULT = new LinkedList<>();
                        HashMap<String, Object> param = new HashMap<>();
                        param.put("tipo", a);
                        param.put("id", b);
                        param.put("isArray", true);
                        RESULT.add(param);
                    :}
;

RETURN_STMT ::= RETURN EXPRESION:a FINCADENA
                {: RESULT = new Return(a, aleft, aright); :}
              | RETURN:r FINCADENA
                {: RESULT = new Return(rleft, rright); :}
;

START_STMT ::= START ID:a PAR1 PARAMETROS_LLAMADA:b PAR2 FINCADENA
               {: RESULT = new Start(a, b, aleft, aright); :}
             | START ID:a PAR1 PAR2 FINCADENA
               {: RESULT = new Start(a, new LinkedList<>(), aleft, aright); :}
;

LLAMADA_INST ::= ID:a PAR1 PARAMETROS_LLAMADA:b PAR2 FINCADENA
                 {: RESULT = new Llamada(a, b, aleft, aright); :}
               | ID:a PAR1 PAR2 FINCADENA
                 {: RESULT = new Llamada(a, new LinkedList<>(), aleft, aright); :}
;

PARAMETROS_LLAMADA ::= PARAMETROS_LLAMADA:a COMA EXPRESION:b
                       {: RESULT = a; RESULT.add(b); :}
                     | EXPRESION:a
                       {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;